import { AnthropicVertex } from "@anthropic-ai/vertex-sdk";
import {
  z
} from "genkit";
import {
  GenerationCommonConfigSchema,
  getBasicUsageStats,
  modelRef
} from "genkit/model";
import { model as pluginModel } from "genkit/plugin";
import { getGenkitClientHeader } from "../../common/index.js";
import { checkModelName } from "./utils.js";
const AnthropicConfigSchema = GenerationCommonConfigSchema.extend({
  location: z.string().optional()
}).passthrough();
function commonRef(name, info, configSchema = AnthropicConfigSchema) {
  return modelRef({
    name: `vertex-model-garden/${name}`,
    configSchema,
    info: info ?? {
      supports: {
        multiturn: true,
        media: true,
        tools: true,
        systemRole: true,
        output: ["text"]
      }
    }
  });
}
const GENERIC_MODEL = commonRef("anthropic");
const KNOWN_MODELS = {
  "claude-haiku-4-5@20251001": commonRef("claude-haiku-4-5@20251001"),
  "claude-sonnet-4-5@20250929": commonRef("claude-sonnet-4-5@20250929"),
  "claude-sonnet-4@20250514": commonRef("claude-sonnet-4@20250514"),
  "claude-opus-4-1@20250805": commonRef("claude-opus-4-1@20250805"),
  "claude-opus-4@20250514": commonRef("claude-opus-4@20250514"),
  "claude-3-5-haiku@20241022": commonRef("claude-3-5-haiku@20241022"),
  "claude-3-haiku@20240307": commonRef("claude-3-haiku@20240307")
};
function isAnthropicModelName(value) {
  return !!value?.startsWith("claude-");
}
function model(version, options = {}) {
  const name = checkModelName(version);
  return modelRef({
    name: `vertex-model-garden/${name}`,
    config: options,
    configSchema: AnthropicConfigSchema,
    info: {
      ...GENERIC_MODEL.info
    }
  });
}
function listActions(clientOptions) {
  return [];
}
function listKnownModels(clientOptions, pluginOptions) {
  return Object.keys(KNOWN_MODELS).map(
    (name) => defineModel(name, clientOptions, pluginOptions)
  );
}
function defineModel(name, clientOptions, pluginOptions) {
  const clients = {};
  const clientFactory = (region) => {
    if (!clients[region]) {
      clients[region] = new AnthropicVertex({
        region,
        projectId: clientOptions.projectId,
        defaultHeaders: {
          "X-Goog-Api-Client": getGenkitClientHeader()
        }
      });
    }
    return clients[region];
  };
  const ref = model(name);
  return pluginModel(
    {
      name: ref.name,
      ...ref.info,
      configSchema: ref.configSchema
    },
    async (request, { streamingRequested, sendChunk }) => {
      const client = clientFactory(
        request.config?.location || clientOptions.location
      );
      const modelVersion = checkModelName(ref.name);
      const anthropicRequest = toAnthropicRequest(modelVersion, request);
      if (!streamingRequested) {
        const response = await client.messages.create({
          ...anthropicRequest,
          stream: false
        });
        return fromAnthropicResponse(request, response);
      } else {
        const stream = await client.messages.stream(anthropicRequest);
        for await (const event of stream) {
          if (event.type === "content_block_delta") {
            sendChunk({
              index: 0,
              content: [
                {
                  text: event.delta.text
                }
              ]
            });
          }
        }
        return fromAnthropicResponse(request, await stream.finalMessage());
      }
    }
  );
}
function toAnthropicRequest(model2, input) {
  let system = void 0;
  const messages = [];
  for (const msg of input.messages) {
    if (msg.role === "system") {
      system = msg.content.map((c) => {
        if (!c.text) {
          throw new Error(
            "Only text context is supported for system messages."
          );
        }
        return c.text;
      }).join();
    } else if (msg.content[msg.content.length - 1].toolResponse) {
      messages.push({
        role: "user",
        content: toAnthropicContent(msg.content)
      });
    } else {
      messages.push({
        role: toAnthropicRole(msg.role),
        content: toAnthropicContent(msg.content)
      });
    }
  }
  const request = {
    model: model2,
    messages,
    // https://docs.anthropic.com/claude/docs/models-overview#model-comparison
    max_tokens: input.config?.maxOutputTokens ?? 4096
  };
  if (system) {
    request["system"] = system;
  }
  if (input.tools) {
    request.tools = input.tools?.map((tool) => {
      return {
        name: tool.name,
        description: tool.description,
        input_schema: tool.inputSchema
      };
    });
  }
  if (input.config?.stopSequences) {
    request.stop_sequences = input.config?.stopSequences;
  }
  if (input.config?.temperature) {
    request.temperature = input.config?.temperature;
  }
  if (input.config?.topK) {
    request.top_k = input.config?.topK;
  }
  if (input.config?.topP) {
    request.top_p = input.config?.topP;
  }
  return request;
}
function toAnthropicContent(content) {
  return content.map((p) => {
    if (p.text) {
      return {
        type: "text",
        text: p.text
      };
    }
    if (p.media) {
      let b64Data = p.media.url;
      if (b64Data.startsWith("data:")) {
        b64Data = b64Data.substring(b64Data.indexOf(",") + 1);
      }
      return {
        type: "image",
        source: {
          type: "base64",
          data: b64Data,
          media_type: p.media.contentType
        }
      };
    }
    if (p.toolRequest) {
      return toAnthropicToolRequest(p.toolRequest);
    }
    if (p.toolResponse) {
      return toAnthropicToolResponse(p);
    }
    throw new Error(`Unsupported content type: ${JSON.stringify(p)}`);
  });
}
function toAnthropicRole(role) {
  if (role === "model") {
    return "assistant";
  }
  if (role === "user") {
    return "user";
  }
  if (role === "tool") {
    return "assistant";
  }
  throw new Error(`Unsupported role type ${role}`);
}
function fromAnthropicTextPart(part) {
  return {
    text: part.text
  };
}
function fromAnthropicToolCallPart(part) {
  return {
    toolRequest: {
      name: part.name,
      input: part.input,
      ref: part.id
    }
  };
}
function fromAnthropicPart(part) {
  if (part.type === "text") return fromAnthropicTextPart(part);
  if (part.type === "tool_use") return fromAnthropicToolCallPart(part);
  throw new Error(
    "Part type is unsupported/corrupted. Either data is missing or type cannot be inferred from type."
  );
}
function fromAnthropicResponse(input, response) {
  const parts = response.content;
  const message = {
    role: "model",
    content: parts.map(fromAnthropicPart)
  };
  return {
    message,
    finishReason: toGenkitFinishReason(
      response.stop_reason
    ),
    custom: {
      id: response.id,
      model: response.model,
      type: response.type
    },
    usage: {
      ...getBasicUsageStats(input.messages, message),
      inputTokens: response.usage.input_tokens,
      outputTokens: response.usage.output_tokens
    }
  };
}
function toGenkitFinishReason(reason) {
  switch (reason) {
    case "end_turn":
      return "stop";
    case "max_tokens":
      return "length";
    case "stop_sequence":
      return "stop";
    case "tool_use":
      return "stop";
    case null:
      return "unknown";
    default:
      return "other";
  }
}
function toAnthropicToolRequest(tool) {
  if (!tool.name) {
    throw new Error("Tool name is required");
  }
  if (!/^[a-zA-Z0-9_-]{1,64}$/.test(tool.name)) {
    throw new Error(
      `Tool name ${tool.name} contains invalid characters.
      Only letters, numbers, and underscores are allowed,
      and the name must be between 1 and 64 characters long.`
    );
  }
  const declaration = {
    type: "tool_use",
    id: tool.ref,
    name: tool.name,
    input: tool.input
  };
  return declaration;
}
function toAnthropicToolResponse(part) {
  if (!part.toolResponse?.ref) {
    throw new Error("Tool response reference is required");
  }
  if (!part.toolResponse.output) {
    throw new Error("Tool response output is required");
  }
  return {
    type: "tool_result",
    tool_use_id: part.toolResponse.ref,
    content: JSON.stringify(part.toolResponse.output)
  };
}
export {
  AnthropicConfigSchema,
  GENERIC_MODEL,
  KNOWN_MODELS,
  defineModel,
  fromAnthropicResponse,
  isAnthropicModelName,
  listActions,
  listKnownModels,
  model,
  toAnthropicRequest
};
//# sourceMappingURL=anthropic.mjs.map